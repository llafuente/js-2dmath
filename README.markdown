# js-2dmath [![Build Status](https://secure.travis-ci.org/llafuente/js-2dmath.png?branch=master)](http://travis-ci.org/llafuente/js-2dmath)


Fast 2d geometry math: Vector2, Rectangle, Circle, Matrix2x3 (2D transformation), Circle, BoundingBox, Line2, Segment2, Intersections, Distances, Transitions (animation/tween), Noise, Random numbers.

So the objective is "**Be fast**"


## Help needed / TODO LIST

* API completeness
* Testing
* did I miss anything useful?


## Performance? HOW?/TIPS

* avoid **new**
* use arrays instead of objects, this is huge performance boost!
* avoid creating unnecessary variables.
* cache every function call to a single variable. example: Vec2.add -> vec2_add
* avoid return *new* arrays (except for create/clone)
* if you access two time an array, cache it

I'm sure i miss some of my own performance tips, PR if you find any error or find a better way!

## Browser

```bash
npm run-script browserify
```

Will generate js-2dmath-browser.js that you can include in any browser.

## API

This doc is autogenerated with falafel see doc.js for more fun! :)


<!-- api-doc -->

[Vec2](#Vec2), [Line2](#Line2), [Segment2](#Segment2), [Rectangle](#Rectangle), [BB2](#BB2), [Circle](#Circle), [Matrix2D](#Matrix2D), [Polygon](#Polygon), [Beizer](#Beizer), [Triangle](#Triangle), [Intersection](#Intersection), [Distance](#Distance), [Transitions](#Transitions), [Xorshift](#Xorshift), [Noise](#Noise)




<a name="Vec2"></a>
## Vec2

<a name="Vec2-create"></a>
* **create** (*x*: Number, *y*: Number): Vec2

  Create a Vec2 given two coords


<a name="Vec2-dFromPolar"></a>
* **dFromPolar** (*length*: Number, *degrees*: Number (Degrees)): Vec2

  Create a Vec2 given length and angle


<a name="Vec2-fromPolar"></a>
* **fromPolar** (*length*: Number, *radians*: Number (Radians)): Vec2

  Create a Vec2 given length and angle


<a name="Vec2-zero"></a>
* **zero** (): Vec2

  Create an empty Vec2


<a name="Vec2-clone"></a>
* **clone** (*v1*: Vec2): Vec2

  Clone given vec2


<a name="Vec2-equals"></a>
* **equals** (*v1*: Vec2, *v2*: Vec2): Boolean

  Returns true if both vectors are equal(same coords)


<a name="Vec2-equalsEpsilon"></a>
* **equalsEpsilon** (*v1*: Vec2, *v2*: Vec2): Boolean

  Returns true if both vectors are "almost(Math.EPS)" equal


<a name="Vec2-gt"></a>
* **gt** (*v1*: Vec2, *v2*: Vec2): Boolean

  Returns true both coordinates of v1 area greater than v2


<a name="Vec2-lt"></a>
* **lt** (*v1*: Vec2, *v2*: Vec2): Boolean

  Returns true both coordinates of v1 area lesser than v2


<a name="Vec2-near"></a>
* **near** (*v1*: Vec2, *v2*: Vec2, *dist*: Number): Boolean

  Returns true if the distance between v1 and v2 is less than dist.


<a name="Vec2-isValid"></a>
* **isValid** (*v1*: Vec2): Boolean

  The vector does not contain any not number value: ±Infinity || NaN


<a name="Vec2-isNaN"></a>
* **isNaN** (*v1*: Vec2): Boolean

  Any coordinate is NaN


<a name="Vec2-copy"></a>
* **copy** (*out*: Vec2, *v1*: Vec2): Vec2

  Copy v1 into out


<a name="Vec2-negate"></a>
* **negate** (*out*: Vec2, *v1*: Vec2): Vec2

  Negate v1 and return it into out


<a name="Vec2-perpendicular"></a>
* **perpendicular** (*out*: Vec2, *v1*: Vec2): Vec2

  Negate v1 and return it into out


<a name="Vec2-normalize"></a>
* **normalize** (*out*: Vec2, *v1*: Vec2): Vec2

<a name="Vec2-rperpendicular"></a>
* **rperpendicular** (*out*: Vec2, *v1*: Vec2): Vec2

<a name="Vec2-lerp"></a>
* **lerp** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2, *t*: Number): Vec2

  Linearly interpolate between a and b.


<a name="Vec2-lerpconst"></a>
* **lerpconst** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2, *d*: Number): Vec2

  Linearly interpolate between v1 towards v2 by distance d.


<a name="Vec2-slerp"></a>
* **slerp** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2, *t*: Number): Vec2

  Spherical linearly interpolate between v1 and v2.


<a name="Vec2-slerpconst"></a>
* **slerpconst** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2, *radians*: Number (Radians)): Vec2

  Spherical linearly interpolate between v1 towards v2 by no more than angle a in radians.


<a name="Vec2-forAngle"></a>
* **forAngle** (*v1*: Vec2, *radians*: Number (Radians)): Vec2

  Returns the unit length vector for the given angle(in radians).


<a name="Vec2-project"></a>
* **project** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

  Returns the vector projection of v1 onto v2.


<a name="Vec2-rotate"></a>
* **rotate** (*out*: Vec2, *v1*: Vec2, *radians*: Number (Radians), *center*: Vec2): Vec2

  Rotates the point by the given angle around an optional center point.

  The object itself is not modified.

  Read more about angle units and orientation in the description of the

  {@link #angle} property.


<a name="Vec2-rotateVec"></a>
* **rotateVec** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-unrotateVec"></a>
* **unrotateVec** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-midPoint"></a>
* **midPoint** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-reflect"></a>
* **reflect** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-subtract"></a>
* **subtract** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-subtract2"></a>
* **subtract2** (*out*: Vec2, *v1*: Vec2, *x*: Number, *y*: Number): Vec2

<a name="Vec2-add"></a>
* **add** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-add2"></a>
* **add2** (*out*: Vec2, *v1*: Vec2, *x*: Number, *y*: Number): Vec2

<a name="Vec2-multiply"></a>
* **multiply** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-multiply2"></a>
* **multiply2** (*out*: Vec2, *v1*: Vec2, *x*: Number, *y*: Number): Vec2

<a name="Vec2-divide"></a>
* **divide** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-divide2"></a>
* **divide2** (*out*: Vec2, *v1*: Vec2, *x*: Number, *y*: Number): Vec2

<a name="Vec2-scale"></a>
* **scale** (*out*: Vec2, *v1*: Vec2, *factor*: Number): Vec2

<a name="Vec2-pow"></a>
* **pow** (*out*: Vec2, *v1*: Vec2, *factor*: Number): Vec2

<a name="Vec2-max"></a>
* **max** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-min"></a>
* **min** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2): Vec2

<a name="Vec2-abs"></a>
* **abs** (*out*: Vec2, *v1*: Vec2): Vec2

<a name="Vec2-scaleAndAdd"></a>
* **scaleAndAdd** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2, *factor*: Number): Vec2

<a name="Vec2-clamp"></a>
* **clamp** (*out*: Vec2, *v1*: Vec2, *length*: Number): Vec2

<a name="Vec2-magnitude"></a>
* **magnitude** (*v1*: Vec2, *v2*: Vec2): Number

<a name="Vec2-compare"></a>
* **compare** (*v1*: Vec2, *v2*: Vec2): Number

  0 equal, 1 top, 2 top-right, 3 right, 4 bottom right, 5 bottom, 6 bottom-left, 7 left, 8 top-left


<a name="Vec2-dot"></a>
* **dot** (*v1*: Vec2, *v2*: Vec2): Number

  Vector dot product.


<a name="Vec2-cross"></a>
* **cross** (*v1*: Vec2, *v2*: Vec2): Number

<a name="Vec2-toAngle"></a>
* **toAngle** (*v1*: Vec2): Number

<a name="Vec2-angleTo"></a>
* **angleTo** (*v1*: Vec2, *v2*: Vec2): Number

<a name="Vec2-distance"></a>
* **distance** (*v1*: Vec2, *v2*: Vec2): Number

  Returns the distance between v1 and v2.


<a name="Vec2-sqrDistance"></a>
* **sqrDistance** (*v1*: Vec2, *v2*: Vec2): Number

  you length only need to compare lengths.


<a name="Vec2-length"></a>
* **length** (*v1*: Vec2): Number

  Returns the length.


<a name="Vec2-sqrLength"></a>
* **sqrLength** (*v1*: Vec2): Number

<a name="Vec2-within"></a>
* **within** (*v1*: Vec2, *v2*: Vec2, *v3*: Vec2): Number

  Return true if v2 is between v1 and v3(inclusive)


<a name="Vec2-$within"></a>
* **$within** (*px*: Number, *py*: Number, *qx*: Number, *qy*: Number, *rx*: Number, *ry*: Number): Number

  Return true if q is between p and r(inclusive)


<a name="Vec2-perp"></a>
* **perp** (*out*: Vec2, *v1*: Vec2)

  **see**: [perpendicular](#Vec2-perpendicular)


<a name="Vec2-rotateCW"></a>
* **rotateCW** (*out*: Vec2, *v1*: Vec2)

  **see**: [perpendicular](#Vec2-perpendicular)


<a name="Vec2-rerp"></a>
* **rerp** (*out*: Vec2, *v1*: Vec2)

  **see**: [rperpendicular](#Vec2-rperpendicular)


<a name="Vec2-rotateCCW"></a>
* **rotateCCW** (*out*: Vec2, *v1*: Vec2)

  **see**: [rperpendicular](#Vec2-rperpendicular)


<a name="Vec2-interpolate"></a>
* **interpolate** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2, *t*: Number)

  **see**: [lerp](#Vec2-lerp)


<a name="Vec2-angle"></a>
* **angle** (*v1*: Vec2)

  **see**: [toAngle](#Vec2-toAngle)


<a name="Vec2-eq"></a>
* **eq** (*v1*: Vec2, *v2*: Vec2)

  **see**: [equals](#Vec2-equals)


<a name="Vec2-sub"></a>
* **sub** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2)

  **see**: [subtract](#Vec2-subtract)


<a name="Vec2-sub2"></a>
* **sub2** (*out*: Vec2, *v1*: Vec2, *x*: Number, *y*: Number)

  **see**: [subtract2](#Vec2-subtract2)


<a name="Vec2-mul"></a>
* **mul** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2)

  **see**: [multiply](#Vec2-multiply)


<a name="Vec2-mul2"></a>
* **mul2** (*out*: Vec2, *v1*: Vec2, *x*: Number, *y*: Number)

  **see**: [multiply2](#Vec2-multiply2)


<a name="Vec2-div"></a>
* **div** (*out*: Vec2, *v1*: Vec2, *v2*: Vec2)

  **see**: [divide](#Vec2-divide)


<a name="Vec2-div2"></a>
* **div2** (*out*: Vec2, *v1*: Vec2, *x*: Number, *y*: Number)

  **see**: [divide2](#Vec2-divide2)


<a name="Vec2-distanceSq"></a>
* **distanceSq** (*v1*: Vec2, *v2*: Vec2)

  **see**: [sqrDistance](#Vec2-sqrDistance)


<a name="Vec2-lengthSq"></a>
* **lengthSq** (*v1*: Vec2)

  **see**: [sqrLength](#Vec2-sqrLength)



<a name="Line2"></a>
## Line2

<a name="Line2-create"></a>
* **create** (*x*: Number, *y*: Number, *m*: Number): Line2

<a name="Line2-zero"></a>
* **zero** (): Line2

<a name="Line2-fromVec2"></a>
* **fromVec2** (*v1*: Vec2, *v2*: Vec2): Line2

<a name="Line2-from2Points"></a>
* **from2Points** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number): Line2

<a name="Line2-fromSegment2"></a>
* **fromSegment2** (*seg2*: Segment2): Line2

<a name="Line2-copy"></a>
* **copy** (*out*: Line2, *line2*: Line2): Line2

<a name="Line2-clone"></a>
* **clone** (*line2*: Line2): Line2

<a name="Line2-add"></a>
* **add** (*out*: Line2, *line2*: Line2, *v1*: Vec2): Line2

<a name="Line2-subtract"></a>
* **subtract** (*out*: Line2, *line2*: Line2, *v1*: Vec2): Line2

<a name="Line2-offset"></a>
* **offset** (*out*: Line2, *line2*: Line2, *offset*: Number): Line2

<a name="Line2-rotate"></a>
* **rotate** (*out*: Line2, *line2*: Line2, *radians*: Number (Radians)): Line2

<a name="Line2-closetPoint"></a>
* **closetPoint** (*out_vec2*: Vec2, *line2*: Line2, *vec2*: Vec2)

  @todo

  **source**: [http://mathcentral.uregina.ca/QQ/database/QQ.09.04/carly1.html](http://mathcentral.uregina.ca/QQ/database/QQ.09.04/carly1.html)


<a name="Line2-reflection"></a>
* **reflection** ()

<a name="Line2-translate"></a>
* **translate** (*out*: Line2, *line2*: Line2, *v1*: Vec2)

  **see**: [add](#Line2-add)


<a name="Line2-sub"></a>
* **sub** (*out*: Line2, *line2*: Line2, *v1*: Vec2)

  **see**: [subtract](#Line2-subtract)



<a name="Segment2"></a>
## Segment2

<a name="Segment2-create"></a>
* **create** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number): Segment2

<a name="Segment2-clone"></a>
* **clone** (*seg2*: Segment2): Segment2

<a name="Segment2-copy"></a>
* **copy** (*out*: Segment2, *seg2*: Segment2): Segment2

<a name="Segment2-translate"></a>
* **translate** (*out*: Segment2, *seg2*: Segment2, *vec2*: Vec2): Segment2

<a name="Segment2-length"></a>
* **length** (*seg2*: Segment2): Number

<a name="Segment2-sqrLength"></a>
* **sqrLength** (*seg2*: Segment2): Number

<a name="Segment2-midPoint"></a>
* **midPoint** (*out_vec2*: Vec2, *seg2*: Segment2): Vec2

<a name="Segment2-slope"></a>
* **slope** (*seg2*: Segment2): Number

<a name="Segment2-cross"></a>
* **cross** (*seg2*: Segment2, *vec2*: Vec2): Number

<a name="Segment2-isCollinear"></a>
* **isCollinear** (*seg2*: Segment2, *vec2*: Vec2): Boolean

<a name="Segment2-isParallel"></a>
* **isParallel** (*seg2*: Segment2, *seg2_2*: Segment2): Boolean

  @todo do it!


<a name="Segment2-isInside"></a>
* **isInside** (*seg2*: Segment2, *vec2*: Vec2): Boolean

<a name="Segment2-closestPoint"></a>
* **closestPoint** (*out_vec2*: Vec2, *seg2*: Segment2, *vec2*: Vec2): Vec2

<a name="Segment2-$closestPoint"></a>
* **$closestPoint** (*out_vec2*: Vec2, *x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number, *x3*: Number, *y3*: Number): Vec2

<a name="Segment2-$collinear"></a>
* **$collinear** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number, *x3*: Number, *y3*: Number): Boolean

<a name="Segment2-$inside"></a>
* **$inside** (*x1*: Number, *x2*: Number, *y1*: Number, *y2*: Number, *x3*: Number, *y3*: Number): Boolean

<a name="Segment2-lengthSq"></a>
* **lengthSq** (*seg2*: Segment2)

  **see**: [sqrLength](#Segment2-sqrLength)


<a name="Segment2-contains"></a>
* **contains** (*seg2*: Segment2, *vec2*: Vec2)

  **see**: [isInside](#Segment2-isInside)



<a name="Rectangle"></a>
## Rectangle

<a name="Rectangle-create"></a>
* **create** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number): Rectangle

  Rectangle is an array with [a: Vec2, b: Vec2, normalized: Boolean]


<a name="Rectangle-fromBB"></a>
* **fromBB** (*bb2*: BB2): Rectangle

<a name="Rectangle-zero"></a>
* **zero** (): Rectangle

<a name="Rectangle-clone"></a>
* **clone** (*rect*: Rectangle): Rectangle

<a name="Rectangle-copy"></a>
* **copy** (*out*: Rectangle, *rect*: Rectangle): Rectangle

<a name="Rectangle-normalize"></a>
* **normalize** (*out*: Rectangle, *rect*: Rectangle, *force*: Boolean): Rectangle

  a -> bottom-left

  a -> top-right


<a name="Rectangle-center"></a>
* **center** (*out_vec2*: Vec2, *rect*: Rectangle): Vec2

<a name="Rectangle-translate"></a>
* **translate** (*out*: Rectangle, *rect*: Rectangle, *vec2*: Vec2): Rectangle

<a name="Rectangle-distance"></a>
* **distance** (*rect*: Rectangle, *rect2*: Rectangle): Number

<a name="Rectangle-area"></a>
* **area** (*rect*: Rectangle): Number

<a name="Rectangle-isInside"></a>
* **isInside** (*rect*: Rectangle, *vec2*: Vec2): Boolean


<a name="BB2"></a>
## BB2
* **TOPLEFT** = 1
* **TOPMIDDLE** = 2
* **TOPRIGHT** = 3
* **CENTERLEFT** = 4
* **CENTER** = 5
* **CENTERRIGHT** = 6
* **BOTTOMLEFT** = 7
* **BOTTOM** = 8
* **BOTTOMRIGHT** = 9

<a name="BB2-create"></a>
* **create** (*l*: Number, *b*: Number, *r*: Number, *t*: Number): BB2

  BoundingBox2 is an array [left: Number, bottom: Number, right: Number, top: Number, nomalized: Boolean]


<a name="BB2-fromCircle"></a>
* **fromCircle** (*circle*: Circle): BB2

<a name="BB2-fromRectangle"></a>
* **fromRectangle** (*rect*: Rectangle): BB2

<a name="BB2-zero"></a>
* **zero** (): BB2

<a name="BB2-clone"></a>
* **clone** (*bb2*: BB2): BB2

<a name="BB2-copy"></a>
* **copy** (*out*: BB2, *bb2*: BB2): BB2

<a name="BB2-merge"></a>
* **merge** (*out*: BB2, *bb2_1*: BB2, *bb2_2*: BB2): BB2

<a name="BB2-offsetMerge"></a>
* **offsetMerge** (*out*: BB2, *bb2_1*: BB2, *bb2_2*: BB2, *vec2_offset*: Vec2): BB2

<a name="BB2-osMerge"></a>
* **osMerge** (*out*: BB2, *bb2_1*: BB2, *bb2_2*: BB2, *vec2_offset*: Vec2, *vec2_scale*: Vec2): BB2

  offset & scale merge


<a name="BB2-area"></a>
* **area** (*bb2*: BB2): Number

<a name="BB2-normalize"></a>
* **normalize** (*out*: BB2, *bb2*: BB2): BB2

<a name="BB2-translate"></a>
* **translate** (*out*: BB2, *bb2*: BB2, *vec2*: Vec2): BB2

<a name="BB2-clampVec"></a>
* **clampVec** (*out_vec2*: Vec2, *bb2*: BB2, *vec2*: Vec2): Vec2

<a name="BB2-align"></a>
* **align** (*out_vec2*: Vec2, *bb2*: BB2, *alignament*: Number): Vec2

  alignament values: BB2.TOPLEFT, BB2.TOPMIDDLE, BB2.TOPRIGHT, BB2.CENTERLEFT, BB2.CENTER, BB2.CENTERRIGHT, BB2.BOTTOMLEFT, BB2.BOTTOM, BB2.BOTTOMRIGH



<a name="Circle"></a>
## Circle

<a name="Circle-create"></a>
* **create** (*x*: Number, *y*: Number, *radius*: Number): Circle

<a name="Circle-fromVec2"></a>
* **fromVec2** (*vec2*: Vec2, *radius*: Number): Circle

<a name="Circle-fromSegment2"></a>
* **fromSegment2** (*seg2*: Segment2): Circle

  Create a Circle with seg2 as diameter


<a name="Circle-fromRectangle"></a>
* **fromRectangle** (*rect*: Rectangle, *inside*: Boolean): Circle

<a name="Circle-fromTriangle"></a>
* **fromTriangle** (*tri*: Triangle, *inside*: Boolean, *circumcenter*: Boolean): Circle

  @todo review inside cases


<a name="Circle-clone"></a>
* **clone** (*circle*: Circle): Circle

<a name="Circle-copy"></a>
* **copy** (*out*: Circle, *circle*: Circle): Circle

<a name="Circle-translate"></a>
* **translate** (*out*: Circle, *circle*: Circle, *vec2*: Vec2): Circle

<a name="Circle-distance"></a>
* **distance** (*circle*: Circle, *circle_2*: Circle): Number

<a name="Circle-length"></a>
* **length** (*circle*: Circle): Number

<a name="Circle-area"></a>
* **area** (*circle*: Circle): Number

<a name="Circle-isInside"></a>
* **isInside** (*circle*: Circle, *vec2*: Vec2): Boolean


<a name="Matrix2D"></a>
## Matrix2D

<a name="Matrix2D-create"></a>
* **create** (): Matrix2D

  Creates a new identity 2x3 matrix


<a name="Matrix2D-fromPoints"></a>
* **fromPoints** (): Matrix2D

  Creates a new matrix given 4 points(a Rectangle)

  @todo

  **link**: [http://jsfiddle.net/dFrHS/1/](http://jsfiddle.net/dFrHS/1/)


<a name="Matrix2D-copy"></a>
* **copy** (*out*: Matrix2D, *m2d*: Matrix2D): Matrix2D

  Copy m2d into out


<a name="Matrix2D-identity"></a>
* **identity** (*out*: Matrix2D): Matrix2D

  Copy m2d into out


<a name="Matrix2D-dRotate"></a>
* **dRotate** (*out*: Matrix2D, *m2d*: Matrix2D, *degrees*: Number (Degrees)): Matrix2D

  Rotates a Matrix2D by the given angle in degrees(increment rotation)

  @note increment rotation


<a name="Matrix2D-rotate"></a>
* **rotate** (*out*: Matrix2D, *m2d*: Matrix2D, *radians*: Number (Radians)): Matrix2D

  Rotates a Matrix2D by the given angle in radians(increment rotation)

  @note increment rotation


<a name="Matrix2D-dRotation"></a>
* **dRotation** (*out*: Matrix2D, *m2d*: Matrix2D, *degrees*: Number (Degrees)): Matrix2D

  Set rotation of a Matrix2D by the given angle in degrees(set rotation)

  @note set rotation


<a name="Matrix2D-rotation"></a>
* **rotation** (*out*: Matrix2D, *m2d*: Matrix2D, *radians*: Number (Radians)): Matrix2D

  Set rotation of a Matrix2D by the given angle in radians(set rotation)

  @note set rotation


<a name="Matrix2D-translate"></a>
* **translate** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2): Matrix2D

  Translates given Matrix2D by the dimensions in the given vec2

  @note This translation is affected by rotation/skew

  @note increment position

  **see**: [gTranslate](#Matrix2D-gTranslate)


<a name="Matrix2D-gTranslate"></a>
* **gTranslate** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2): Matrix2D

  Translates given Matrix2D by the dimensions in the given vec2

  @note This translation is NOT affected by rotation/skew

  @note increment position

  **see**: [translate](#Matrix2D-translate)


<a name="Matrix2D-position"></a>
* **position** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2): Matrix2D

  Set Matrix2D position

  @note This translation is NOT affected by rotation/skew

  @note set position

  **see**: [gTranslate](#Matrix2D-gTranslate)

  **see**: [translate](#Matrix2D-translate)


<a name="Matrix2D-scale"></a>
* **scale** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2): Matrix2D

  Scales the Matrix2D by the dimensions in the given vec2

  @note incremental scale

  @note do not affect position

  **see**: [scalation](#Matrix2D-scalation)


<a name="Matrix2D-scalation"></a>
* **scalation** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2): Matrix2D

  Set the Matrix2D scale by the dimensions in the given vec2

  @note set scale

  @note do not affect position

  **see**: [scale](#Matrix2D-scale)


<a name="Matrix2D-dSkewX"></a>
* **dSkewX** (*out*: Matrix2D, *m2d*: Matrix2D, *degrees*: Number (Degrees)): Matrix2D

  Increment the Matrix2D x-skew by given degrees

  @note increment skewX

  **see**: [skewX](#Matrix2D-skewX)


<a name="Matrix2D-skewX"></a>
* **skewX** (*out*: Matrix2D, *m2d*: Matrix2D, *radians*: Number (Radians)): Matrix2D

  Increment the Matrix2D x-skew by given radians

  @note increment skewX


<a name="Matrix2D-dSkewY"></a>
* **dSkewY** (*out*: Matrix2D, *m2d*: Matrix2D, *degrees*: Number (Degrees)): Matrix2D

  Increment the Matrix2D y-skew by given degrees

  @note increment skewY


<a name="Matrix2D-skewY"></a>
* **skewY** (*out*: Matrix2D, *m2d*: Matrix2D, *radians*: Number (Radians)): Matrix2D

  Increment the Matrix2D y-skew by given radians

  @note increment skewY


<a name="Matrix2D-dSkew"></a>
* **dSkew** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2_degrees*: Vec2 (Degrees)): Matrix2D

  Increment the Matrix2D skew y by given degrees in vec2_degrees

  @note increment skew

  **see**: [dSetSkew](#Matrix2D-dSetSkew)


<a name="Matrix2D-skew"></a>
* **skew** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2): Matrix2D

  Increment the Matrix2D skew y by given radians in vec2

  @note increment skew


<a name="Matrix2D-dSetSkew"></a>
* **dSetSkew** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2_degrees*: Vec2 (Degrees)): Matrix2D

  Set the Matrix2D skew y by given degrees in vec2_degrees

  @note set skew

  **see**: [setSkew](#Matrix2D-setSkew)


<a name="Matrix2D-setSkew"></a>
* **setSkew** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2): Matrix2D

  Set the Matrix2D skew y by given radians in vec2

  @note set skew


<a name="Matrix2D-multiply"></a>
* **multiply** (*out*: Matrix2D, *m2d*: Matrix2D, *m2d_2*: Matrix2D): Matrix2D

  Multiplies two Matrix2D's


<a name="Matrix2D-multiplyVec2"></a>
* **multiplyVec2** (*out_vec2*: Vec2, *m2d*: Matrix2D, *vec2*: Vec2): Vec2

  Multiplies a Matrix2D and a Vec2


<a name="Matrix2D-getPosition"></a>
* **getPosition** (*out_vec2*: Vec2, *m2d*: Matrix2D): Vec2

  Retrieve current position as Vec2


<a name="Matrix2D-getScale"></a>
* **getScale** (*out_vec2*: Vec2, *m2d*: Matrix2D): Vec2

  Retrieve current scale as Vec2


<a name="Matrix2D-getSkew"></a>
* **getSkew** (*out_vec2*: Vec2, *m2d*: Matrix2D): Vec2

  Retrieve current skew as Vec2


<a name="Matrix2D-reflect"></a>
* **reflect** (*out*: Matrix2D, *m2d*: Matrix2D): Matrix2D

  Alias of rotate 180º(PI)


<a name="Matrix2D-inverse"></a>
* **inverse** (*out*: Matrix2D, *m2d*: Matrix2D)

  @TODO this a transformation matrix, what inverse means for us, mirror ?


<a name="Matrix2D-transpose"></a>
* **transpose** (*out*: Matrix2D, *m2d*: Matrix2D)

  @TODO needed ?


<a name="Matrix2D-determinant"></a>
* **determinant** (*out*: Matrix2D, *m2d*: Matrix2D)

  @TODO review & test


<a name="Matrix2D-translationMatrix"></a>
* **translationMatrix** (*x*: Number, *y*: Number): Matrix2D

  Returns a 3x2 2D column-major translation matrix for x and y.


<a name="Matrix2D-dSkewXMatrix"></a>
* **dSkewXMatrix** (*degrees*: Number (Degrees)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given degrees.


<a name="Matrix2D-skewXMatrix"></a>
* **skewXMatrix** (*radians*: Number (Radians)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given radians.


<a name="Matrix2D-dSkewYMatrix"></a>
* **dSkewYMatrix** (*degrees*: Number (Degrees)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given degrees.


<a name="Matrix2D-skewYMatrix"></a>
* **skewYMatrix** (*radians*: Number (Radians)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given radians.


<a name="Matrix2D-scalingMatrix"></a>
* **scalingMatrix** (*x*: Number, *y*: Number)

  Returns a 3x2 2D column-major scaling matrix for sx and sy.


<a name="Matrix2D-interpolate"></a>
* **interpolate** (*out*: Matrix2D, *m2d*: Matrix2D, *m2d_2*: Matrix2D, *factor*: Number)

  Interpolate two matrixes by given factor.

  Used in conjunction with Transitions and you will have nice transformations :)


<a name="Matrix2D-dSetRotation"></a>
* **dSetRotation** (*out*: Matrix2D, *m2d*: Matrix2D, *degrees*: Number (Degrees))

  **see**: [dRotation](#Matrix2D-dRotation)


<a name="Matrix2D-setRotation"></a>
* **setRotation** (*out*: Matrix2D, *m2d*: Matrix2D, *radians*: Number (Radians))

  **see**: [rotation](#Matrix2D-rotation)


<a name="Matrix2D-setPosition"></a>
* **setPosition** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2)

  **see**: [position](#Matrix2D-position)


<a name="Matrix2D-setScale"></a>
* **setScale** (*out*: Matrix2D, *m2d*: Matrix2D, *vec2*: Vec2)

  **see**: [scalation](#Matrix2D-scalation)



<a name="Polygon"></a>
## Polygon

<a name="Polygon-create"></a>
* **create** (): Polygon

<a name="Polygon-centroid"></a>
* **centroid** (*out_vec2*: Vec2, *poly*: Polygon): Vec2

<a name="Polygon-recenter"></a>
* **recenter** (*out*: Polygon, *poly*: Polygon): Polygon

<a name="Polygon-area"></a>
* **area** (*poly*: Polygon): Number


<a name="Beizer"></a>
## Beizer

<a name="Beizer-cubic"></a>
* **cubic** (*cp0x*: Number, *cp0y*: Number, *cp1x*: Number, *cp1y*: Number, *cp2x*: Number, *cp2y*: Number, *cp3x*: Number, *cp3y*: Number): Beizer

  cp0 - start point

  cp1 - start control point

  cp2 - end control point

  cp3 - end


<a name="Beizer-quadric"></a>
* **quadric** (*cp0x*: Number, *cp0y*: Number, *cp1x*: Number, *cp1y*: Number, *cp2x*: Number, *cp2y*: Number): Beizer

<a name="Beizer-get"></a>
* **get** (*out_vec2*: Vec2, *curve*: Beizer, *t*: Number): Vec2

<a name="Beizer-length"></a>
* **length** (*curve*: Beizer, *step*: Number): Number

  Calculate the curve length by incrementally solving the curve every substep=CAAT.Curve.k. This value defaults

  to .05 so at least 20 iterations will be performed.

  @todo some kind of cache maybe it's needed!



<a name="Triangle"></a>
## Triangle

<a name="Triangle-create"></a>
* **create** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number, *x3*: Number, *y3*: Number): Triangle

  A, B, C


<a name="Triangle-abMidPoint"></a>
* **abMidPoint** (*out_vec2*: Vec2, *tri*: Triangle): Vec2

<a name="Triangle-bcMidPoint"></a>
* **bcMidPoint** (*out_vec2*: Vec2, *tri*: Triangle): Vec2

<a name="Triangle-caMidPoint"></a>
* **caMidPoint** (*out_vec2*: Vec2, *tri*: Triangle): Vec2

<a name="Triangle-midTriangle"></a>
* **midTriangle** (*out*: Triangle, *tri*: Triangle): Triangle

<a name="Triangle-zero"></a>
* **zero** (): Triangle

<a name="Triangle-clone"></a>
* **clone** (*tri*: Triangle): Triangle

<a name="Triangle-copy"></a>
* **copy** (*out*: Triangle, *tri*: Triangle): Triangle

<a name="Triangle-centroid"></a>
* **centroid** (*out_vec2*: Vec2, *tri*: Triangle): Vec2

<a name="Triangle-incenter"></a>
* **incenter** (*out_vec2*: Vec2, *tri*: Triangle): Vec2

<a name="Triangle-circumcenter"></a>
* **circumcenter** (*out_vec2*: Vec2, *tri*: Triangle): Vec2

<a name="Triangle-area"></a>
* **area** (*tri*: Triangle): Number

<a name="Triangle-translate"></a>
* **translate** (*out*: Triangle, *tri*: Triangle, *vec2*: Vec2): Triangle

<a name="Triangle-center"></a>
* **center** (*out_vec2*: Vec2, *tri*: Triangle)

  **see**: [centroid](#Triangle-centroid)



<a name="Intersection"></a>
## Intersection
* **OUTSIDE** = 1
* **PARALLEL** = 2
* **COLLIDE** = 8
* **INSIDE** = 4
* **COINCIDENT** = 16
* **TANGENT** = 32

<a name="Intersection-near"></a>
* **near** (*num*: Number, *num2*: Number)

<a name="Intersection-$rectangle_rectangle"></a>
* **$rectangle_rectangle** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number, *x3*: Number, *y3*: Number, *x4*: Number, *y4*: Number, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-$rectangle_vec2"></a>
* **$rectangle_vec2** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number, *x3*: Number, *y3*: Number, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-$circle_segment2"></a>
* **$circle_segment2** (*cx*: Number, *cy*: Number, *r*: Number, *x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-$circle_rectangle"></a>
* **$circle_rectangle** (*cx*: Number, *cy*: Number, *r*: Number, *x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number, *collision*: Boolean, *distance*: Boolean)

  Use LineP1 instead of LocalP1 because we want our answer in global

  space, not the circle's local space


<a name="Intersection-bb2_bb2"></a>
* **bb2_bb2** (*bb2_1*: BB2, *bb2_2*: BB2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-bb2_vec2"></a>
* **bb2_vec2** (*bb2*: BB2, *vec2*: Vec2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-vec2_bb2"></a>
* **vec2_bb2** (*vec2*: Vec2, *bb2*: BB2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-rectangle_rectangle"></a>
* **rectangle_rectangle** (*rect1*: Rectangle, *rect2*: Rectangle, *collision*: Boolean, *distance*: Boolean)

  TODO segments of collision


<a name="Intersection-bb2_rectangle"></a>
* **bb2_rectangle** (*bb2*: BB2, *rect*: Rectangle, *collision*: Boolean, *distance*: Boolean)

  TODO segments of collision


<a name="Intersection-rectangle_bb2"></a>
* **rectangle_bb2** (*rect*: Rectangle, *bb2*: BB2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-rectangle_vec2"></a>
* **rectangle_vec2** (*rect*: Rectangle, *vec2*: Vec2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-vec2_rectangle"></a>
* **vec2_rectangle** (*vec2*: Vec2, *rect*: Rectangle, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-circle_vec2"></a>
* **circle_vec2** (*circle*: Circle, *vec2*: Vec2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-vec2_circle"></a>
* **vec2_circle** (*vec2*: Vec2, *circle*: Circle, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-circle_circle"></a>
* **circle_circle** (*circle_1*: Circle, *circle_2*: Circle, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-circle_bb2"></a>
* **circle_bb2** (*circle*: Circle, *bb2*: BB2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-bb2_circle"></a>
* **bb2_circle** (*bb2*: BB2, *circle*: Circle, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-circle_rectangle"></a>
* **circle_rectangle** (*circle*: Circle, *rect*: Rectangle, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-rectangle_circle"></a>
* **rectangle_circle** (*rect*: Rectangle, *circle*: Circle, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-circle_segment2"></a>
* **circle_segment2** (*circle*: Circle, *seg2*: Segment2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-segment2_circle"></a>
* **segment2_circle** (*seg2*: Segment2, *circle*: Circle, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-line2_line2"></a>
* **line2_line2** (*line2_1*: Line2, *line2_2*: Line2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-segment2_segment2"></a>
* **segment2_segment2** (*seg2_1*: Segment2, *seg2_2*: Segment2, *collision*: Boolean, *distance*: Boolean)

<a name="Intersection-segment2_vec2"></a>
* **segment2_vec2** (*seg2*: Segment2, *vec2*: Vec2)

  Is the intersection along the the segments


<a name="Intersection-vec2_segment2"></a>
* **vec2_segment2** (*vec2*: Vec2, *seg2*: Segment2)


<a name="Distance"></a>
## Distance

<a name="Distance-fourPoints"></a>
* **fourPoints** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number)

<a name="Distance-sqrFourPoints"></a>
* **sqrFourPoints** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number)

<a name="Distance-line2_vec2"></a>
* **line2_vec2** (*line2*: Line2, *vec2*: Vec2)

<a name="Distance-segment2_vec2"></a>
* **segment2_vec2** (*seg2*: Segment2, *vec2*: Vec2)

<a name="Distance-rectangle_vec2"></a>
* **rectangle_vec2** (*rect*: Rectangle, *vec2*: Vec2)

<a name="Distance-fourPointsSq"></a>
* **fourPointsSq** (*x1*: Number, *y1*: Number, *x2*: Number, *y2*: Number)

  **see**: [sqrFourPoints](#Distance-sqrFourPoints)



<a name="Transitions"></a>
## Transitions
* **LINK_CHAIN** = 1
* **LINK_STOP** = 2
* **LINK_IGNORE** = 3
* **LINK_CANCEL** = 4

<a name="Transitions-Pow"></a>
* **Pow** (*pos*: Number, *x*: Number)

<a name="Transitions-Expo"></a>
* **Expo** (*pos*: Number)

<a name="Transitions-Circ"></a>
* **Circ** (*pos*: Number)

<a name="Transitions-Sine"></a>
* **Sine** (*pos*: Number)

<a name="Transitions-Back"></a>
* **Back** (*pos*: Number, *x*: Number)

<a name="Transitions-Bounce"></a>
* **Bounce** (*pos*: Number)

<a name="Transitions-Elastic"></a>
* **Elastic** (*pos*: Number, *x*: Number)

<a name="Transitions-linear"></a>
* **linear** (*pos*: Number)

  Just return what you sent


<a name="Transitions-create"></a>
* **create** (*name*: String, *transition*: Function)

  Wrap your transaction with In/Out/InOut modifiers.


<a name="Transitions-animate"></a>
* **animate** (*obj*: Object, *prop*: String, *values*: Mixed, *ioptions*: Object)

  Animate object properties.

  *obj* must be writable or at least have defined $__tween

  *prop* property name to animate

  *values* keys are numbers from 0 to 100, values could be anything

  *ioptions*

  **mandatory**

    * **time**: <number> in ms

  **optional**

    * **transition** Transition.XXX, or a valid compatible function Default: linear

    * **link** Transition.LINK_XXX Default: CHAIN

    * **render** function(obj, property, new_value) {}

    * **parser** function(obj, property) { return <value>; }

    * **tickEvent** <string> event name Default: "tick"

    * **endEvent** <string> event name Default: "animation:end"

    * **startEvent** <string> event name Default: "animation:star"

    * **chainEvent** <string> event name Default: "animation:chain"


<a name="Transitions-tween"></a>
* **tween** (*obj*: Object, *params*: Object, *options*: Object)

<a name="Transitions-PowIn"></a>
* **PowIn** (*pos*: Number, *x*: Number)

  **see**: [Pow](#Transitions-Pow)


<a name="Transitions-PowOut"></a>
* **PowOut** (*pos*: Number)

<a name="Transitions-PowInOut"></a>
* **PowInOut** (*pos*: Number)

<a name="Transitions-ExpoIn"></a>
* **ExpoIn** (*pos*: Number)

  **see**: [Expo](#Transitions-Expo)


<a name="Transitions-ExpoOut"></a>
* **ExpoOut** (*pos*: Number)

<a name="Transitions-ExpoInOut"></a>
* **ExpoInOut** (*pos*: Number)

<a name="Transitions-CircIn"></a>
* **CircIn** (*pos*: Number)

  **see**: [Circ](#Transitions-Circ)


<a name="Transitions-CircOut"></a>
* **CircOut** (*pos*: Number)

<a name="Transitions-CircInOut"></a>
* **CircInOut** (*pos*: Number)

<a name="Transitions-SineIn"></a>
* **SineIn** (*pos*: Number)

  **see**: [Sine](#Transitions-Sine)


<a name="Transitions-SineOut"></a>
* **SineOut** (*pos*: Number)

<a name="Transitions-SineInOut"></a>
* **SineInOut** (*pos*: Number)

<a name="Transitions-BackIn"></a>
* **BackIn** (*pos*: Number, *x*: Number)

  **see**: [Back](#Transitions-Back)


<a name="Transitions-BackOut"></a>
* **BackOut** (*pos*: Number)

<a name="Transitions-BackInOut"></a>
* **BackInOut** (*pos*: Number)

<a name="Transitions-BounceIn"></a>
* **BounceIn** (*pos*: Number)

  **see**: [Bounce](#Transitions-Bounce)


<a name="Transitions-BounceOut"></a>
* **BounceOut** (*pos*: Number)

<a name="Transitions-BounceInOut"></a>
* **BounceInOut** (*pos*: Number)

<a name="Transitions-ElasticIn"></a>
* **ElasticIn** (*pos*: Number, *x*: Number)

  **see**: [Elastic](#Transitions-Elastic)


<a name="Transitions-ElasticOut"></a>
* **ElasticOut** (*pos*: Number)

<a name="Transitions-ElasticInOut"></a>
* **ElasticInOut** (*pos*: Number)

<a name="Transitions-Quad"></a>
* **Quad** (*pos*: Number)

<a name="Transitions-QuadIn"></a>
* **QuadIn** (*pos*: Number)

<a name="Transitions-QuadOut"></a>
* **QuadOut** (*pos*: Number)

<a name="Transitions-QuadInOut"></a>
* **QuadInOut** (*pos*: Number)

<a name="Transitions-Cubic"></a>
* **Cubic** (*pos*: Number)

<a name="Transitions-CubicIn"></a>
* **CubicIn** (*pos*: Number)

<a name="Transitions-CubicOut"></a>
* **CubicOut** (*pos*: Number)

<a name="Transitions-CubicInOut"></a>
* **CubicInOut** (*pos*: Number)

<a name="Transitions-Quart"></a>
* **Quart** (*pos*: Number)

<a name="Transitions-QuartIn"></a>
* **QuartIn** (*pos*: Number)

<a name="Transitions-QuartOut"></a>
* **QuartOut** (*pos*: Number)

<a name="Transitions-QuartInOut"></a>
* **QuartInOut** (*pos*: Number)

<a name="Transitions-Quint"></a>
* **Quint** (*pos*: Number)

<a name="Transitions-QuintIn"></a>
* **QuintIn** (*pos*: Number)

<a name="Transitions-QuintOut"></a>
* **QuintOut** (*pos*: Number)

<a name="Transitions-QuintInOut"></a>
* **QuintInOut** (*pos*: Number)


<a name="Xorshift"></a>
## Xorshift

<a name="Xorshift-create"></a>
* **create** (*seeds*: [, Number...])

  Random numbers generator

  Returns an object with three methods

  * uint32()

  * random()

  * fract53()

  **link**: [http://baagoe.com/en/RandomMusings/javascript/](http://baagoe.com/en/RandomMusings/javascript/)

  **link**: [http://en.wikipedia.org/wiki/Xorshift](http://en.wikipedia.org/wiki/Xorshift)

  **source**: [http://jsdo.it/akm2/fhMC/js](http://jsdo.it/akm2/fhMC/js)



<a name="Noise"></a>
## Noise

<a name="Noise-ClassicNoise"></a>
* **ClassicNoise** (*seed*: Number)

  @class ClassicNoise


<a name="Noise-SimplexNoise"></a>
* **SimplexNoise** (*seed*: Number)

  SimplexNoise

  @super ClassicNoise


<a name="Noise-createClassic"></a>
* **createClassic** (*seed*: Number)

<a name="Noise-createSimpleX"></a>
* **createSimpleX** (*seed*: Number)

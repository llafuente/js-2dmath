# js-2dmath [![Build Status](https://secure.travis-ci.org/llafuente/js-2dmath.png?branch=master)](http://travis-ci.org/llafuente/js-2dmath)


Javascript 2D Math (vector, matrix, trigonometry, ...) for high performance

So the objective is "**Be fast as death**" that give in


## Help needed.

For completeness and testing.



## API

This doc is autogenerated with falafel see doc.js :)

Naming convention.

* if you find a method with an argument **out_**, the method won't return, will modify given argument.


## Vec2
* **create** (*x*:Number, *y*:Number): Array

  Create a Vec2 given two coords

* **dFromPolar** (*length*:Number, *degrees*:Number (Degrees)): Array

  Create a Vec2 given length and angle

* **fromPolar** (*length*:Number, *radians*:Number (Radians)): Array

  Create a Vec2 given length and angle

* **zero** (): Array

  Create an empty Vec2

* **clone** (*v1*:Vec2): Array

  Clone given vec2

* **equals** (*v1*:Vec2, *v2*:Vec2): Boolean

  Returns true if both vectors are equal(same coords)

* **equalsEpsilon** (*v1*:Vec2, *v2*:Vec2): Boolean

  Returns true if both vectors are "almost(Math.EPS)" equal

* **gt** (*v1*:Vec2, *v2*:Vec2): Boolean

  Returns true both coordinates of v1 area greater than v2

* **lt** (*v1*:Vec2, *v2*:Vec2): Boolean

  Returns true both coordinates of v1 area lesser than v2

* **near** (*v1*:Vec2, *v2*:Vec2, *dist*:Number): Boolean

  Returns true if the distance between v1 and v2 is less than dist.

* **isValid** (*v1*:Vec2): Boolean

  The vector does not contain any not number value: ±Infinity || NaN

* **isNaN** (*v1*:Vec2): Boolean

  Any coordinate is NaN

* **copy** (*out*:Vec2, *v1*:Vec2): Vec2

  Copy v1 into out

* **negate** (*out*:Vec2, *v1*:Vec2): Vec2

  Negate v1 and return it into out

* **perpendicular** (*out*:Vec2, *v1*:Vec2): Vec2

  Negate v1 and return it into out

* **normalize** (*out*:Vec2, *v1*:Vec2)
* **rperpendicular** (*out*:Vec2, *v1*:Vec2)
* **lerp** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2, *t*:Number)

  Linearly interpolate between a and b.

* **lerpconst** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2, *d*:Number)

  Linearly interpolate between v1 towards v2 by distance d.

* **slerp** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2, *t*:Number)

  Spherical linearly interpolate between v1 and v2.

* **slerpconst** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2, *radians*:Number (Radians))

  Spherical linearly interpolate between v1 towards v2 by no more than angle a in radians.

* **forAngle** (*v1*:Vec2, *radians*:Number (Radians))

  Returns the unit length vector for the given angle(in radians).

* **project** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)

  Returns the vector projection of v1 onto v2.

* **rotate** (*out*:Vec2, *v1*:Vec2, *radians*:Number (Radians), *center*:Vec2)

  Rotates the point by the given angle around an optional center point.

  The object itself is not modified.

  Read more about angle units and orientation in the description of the

  {@link #angle} property.

* **rotateVec** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **unrotateVec** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **midPoint** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **reflect** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **subtract** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **subtract2** (*out*:Vec2, *v1*:Vec2, *x*:Number, *y*:Number)
* **add** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **add2** (*out*:Vec2, *v1*:Vec2, *x*:Number, *y*:Number)
* **multiply** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **multiply2** (*out*:Vec2, *v1*:Vec2, *x*:Number, *y*:Number)
* **divide** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **divide2** (*out*:Vec2, *v1*:Vec2, *x*:Number, *y*:Number)
* **scale** (*out*:Vec2, *v1*:Vec2, *factor*:Number)
* **max** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **min** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2)
* **abs** (*out*:Vec2, *v1*:Vec2)
* **scaleAndAdd** (*out*:Vec2, *v1*:Vec2, *v2*:Vec2, *factor*:Number)
* **clamp** (*out*:Vec2, *v1*:Vec2, *length*:Number)
* **magnitude** (*v1*:Vec2, *v2*:Vec2)
* **compare** (*v1*:Vec2, *v2*:Vec2): Number

  0 equal, 1 top, 2 top-right, 3 right, 4 bottom right, 5 bottom, 6 bottom-left, 7 left, 8 top-left

* **dot** (*v1*:Vec2, *v2*:Vec2)

  Vector dot product.

* **cross** (*v1*:Vec2, *v2*:Vec2)
* **toAngle** (*v1*:Vec2)
* **distance** (*v1*:Vec2, *v2*:Vec2)

  Returns the distance between v1 and v2.

* **sqrDistance** (*v1*:Vec2, *v2*:Vec2)

  you length only need to compare lengths.

* **length** (*v1*:Vec2)

  Returns the length.

* **sqrLength** (*v1*:Vec2)
* **within** (*v1*:Vec2, *v2*:Vec2, *v3*:Vec2)

  Return true if v2 is between v1 and v3(inclusive)

* **$within** (*px*:Number, *py*:Number, *qx*:Number, *qy*:Number, *rx*:Number, *ry*:Number)

  Return true if q is between p and r(inclusive)



## Line2
* **create** (*x*:Number, *y*:Number, *m*:Number)
* **fromPoints** (*x1*:Number, *y1*:Number, *x2*:Number, *y2*:Number)
* **fromSegment2** (*seg2*:Segment2)
* **copy** (*out*:Line2, *l1*:Line2)
* **clone** (*l1*:Line2)
* **add** (*out*:Line2, *l1*:Line2, *v1*:Vec2)
* **subtract** (*out*:Line2, *l1*:Line2, *v1*:Vec2)
* **parallel** (*out*:Line2, *l1*:Line2)


## Segment2
* **create** (*x1*:Number, *y1*:Number, *x2*:Number, *y2*:Number)
* **clone** (*seg2*:Segment2)
* **copy** (*out*:Segment2, *seg2*:Segment2)
* **translate** (*out*:Segment2, *seg2*:Segment2, *vec2*:Vec2)
* **length** (*seg2*:Segment2)
* **sqrLength** (*seg2*:Segment2)
* **cross** (*seg2*:Segment2, *vec2*:Vec2)
* **collinear** (*seg2*:Segment2, *vec2*:Vec2)
* **inside** (*seg2*:Segment2, *vec2*:Vec2)
* **closestPoint** (*out*:Segment2, *seg2*:Segment2, *vec2*:Vec2)
* **$closestPoint** (*out*:Segment2, *x1*:Number, *y1*:Number, *x2*:Number, *y2*:Number, *x3*:Number, *y3*:Number)
* **$collinear** (*x1*:Number, *y1*:Number, *x2*:Number, *y2*:Number, *x3*:Number, *y3*:Number)
* **$inside** (*x1*:Number, *x2*:Number, *y1*:Number, *y2*:Number, *x3*:Number, *y3*:Number)


## Rectangle
* **create** (*x1*:Number, *y1*:Number, *x2*:Number, *y2*:Number)
* **fromBB** (*bb2*:BB2)
* **zero** ()
* **clone** (*rect*:Rectangle)
* **copy** (*out*:Rectangle, *rect*:Rectangle)
* **normalize** (*out*:Rectangle, *rect*:Rectangle, *force*:Boolean)

  a, b, normlize

  a -> bottom-left

  a -> top-right

* **center** (*out_vec2*:Vec2, *rect*:Rectangle)
* **translate** (*out*:Rectangle, *rect*:Rectangle, *vec2*:Vec2)
* **distance** (*rect*:Rectangle, *rect2*:Rectangle)
* **area** (*rect*:Rectangle)


## BB2
* **create** (*l*:Number, *b*:Number, *r*:Number, *t*:Number)
* **fromCircle** (*circle*:Circle)
* **fromRectangle** (*rect*:Rectangle)
* **zero** ()
* **clone** (*bb2*:BB2)
* **copy** (*out*:BB2, *bb2*:BB2)
* **merge** (*out*:BB2, *bb2_1*:BB2, *bb2_2*:BB2)
* **offsetMerge** (*out*:BB2, *bb2_1*:BB2, *bb2_2*:BB2, *vec2_offset*:Vec2)
* **osMerge** (*out*:BB2, *bb2_1*:BB2, *bb2_2*:BB2, *vec2_offset*:Vec2, *vec2_scale*:Vec2)
* **area** (*bb2*:BB2)
* **normalize** (*out*:BB2, *bb2*:BB2)
* **translate** (*out*:BB2, *bb2*:BB2, *vec2*:Vec2)
* **clampVec** (*out*:BB2, *bb2*:BB2, *vec2*:Vec2)
* **align** (*out_vec2*:Vec2, *bb2*:BB2, *alignament*:Number (BB2.TOPLEFT, BB2.TOPMIDDLE, BB2.TOPRIGHT, BB2.CENTERLEFT, BB2.CENTER, BB2.CENTERRIGHT, BB2.BOTTOMLEFT, BB2.BOTTOM, BB2.BOTTOMRIGH))


## Circle
* **create** (*x*:Number, *y*:Number, *radius*:Number)
* **clone** (*circle*:Circle)
* **copy** (*out*:Circle, *circle*:Circle)
* **translate** (*out*:Circle, *circle*:Circle, *vec2*:Vec2)
* **distance** (*circle*:Circle, *circle_2*:Circle)
* **length** (*circle*:Circle)
* **area** (*circle*:Circle)


## Matrix2D
* **create** (): Matrix2D

  Creates a new identity matrix

* **fromPoints** (): Matrix2D

  Creates a new matrix given 4 points(a Rectangle)

* **copy** (*out*:Matrix2D, *m2d*:Matrix2D): Matrix2D

  Copy m2d into out

* **identity** (*out*:Matrix2D): Matrix2D

  Copy m2d into out

* **dRotate** (*out*:Matrix2D, *m2d*:Matrix2D, *degrees*:Number (Degrees)): Matrix2D

  Rotates a Matrix2D by the given angle in degrees(increment rotation)

  @note increment rotation

* **rotate** (*out*:Matrix2D, *m2d*:Matrix2D, *radians*:Number (Radians)): Matrix2D

  Rotates a Matrix2D by the given angle in radians(increment rotation)

  @note increment rotation

* **dRotation** (*out*:Matrix2D, *m2d*:Matrix2D, *degrees*:Number (Degrees)): Matrix2D

  Set rotation of a Matrix2D by the given angle in degrees(set rotation)

  @note set rotation

* **rotation** (*out*:Matrix2D, *m2d*:Matrix2D, *radians*:Number (Radians)): Matrix2D

  Set rotation of a Matrix2D by the given angle in radians(set rotation)

  @note set rotation

* **translate** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2*:Vec2): Matrix2D

  Translates given Matrix2D by the dimensions in the given vec2

  @note This translation is affected by rotation/skew

  @note increment position

  @see    * gtranslate

* **gTranslate** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2*:Vec2): Matrix2D

  Translates given Matrix2D by the dimensions in the given vec2

  @note This translation is NOT affected by rotation/skew

  @note increment position

  @see    * translate

* **position** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2*:Vec2): Matrix2D

  Set Matrix2D position

  @note This translation is NOT affected by rotation/skew

  @note set position

  @see    * gtranslate @see    * translate

* **scale** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2*:Vec2): Matrix2D

  Scales the Matrix2D by the dimensions in the given vec2

  @note incremental scale

  @note do not affect position

  @see    * scalation

* **scalation** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2*:Vec2): Matrix2D

  Set the Matrix2D scale by the dimensions in the given vec2

  @note set scale

  @note do not affect position

  @see    * scalation

* **dSkewX** (*out*:Matrix2D, *m2d*:Matrix2D, *degrees*:Number (Degrees)): Matrix2D

  Increment the Matrix2D x-skew by given degrees

  @note increment skewX

  @see    * scalation

* **skewX** (*out*:Matrix2D, *m2d*:Matrix2D, *radians*:Number (Radians)): Matrix2D

  Increment the Matrix2D x-skew by given radians

  @note increment skewX

  @see    * scalation

* **dSkewY** (*out*:Matrix2D, *m2d*:Matrix2D, *degrees*:Number (Degrees)): Matrix2D

  Increment the Matrix2D y-skew by given degrees

  @note increment skewY

  @see    * scalation

* **skewY** (*out*:Matrix2D, *m2d*:Matrix2D, *radians*:Number (Radians)): Matrix2D

  Increment the Matrix2D y-skew by given radians

  @note increment skewY

  @see    * scalation

* **dSkew** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2_degrees*:Vec2 (Degrees)): Matrix2D

  Increment the Matrix2D skew y by given degrees in vec2_degrees

  @note increment skew

  @see    * dSetSkew

* **skew** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2*:Vec2): Matrix2D

  Increment the Matrix2D skew y by given radians in vec2

  @note increment skew

  @see    * scalation

* **dSetSkew** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2_degrees*:Vec2 (Degrees)): Matrix2D

  Set the Matrix2D skew y by given degrees in vec2_degrees

  @note set skew

  @see    * setSkew

* **setSkew** (*out*:Matrix2D, *m2d*:Matrix2D, *vec2*:Vec2): Matrix2D

  Set the Matrix2D skew y by given radians in vec2

  @note set skew

  @see    * skew

* **multiply** (*out*:Matrix2D, *m2d*:Matrix2D, *m2d_2*:Matrix2D): Matrix2D

  Multiplies two Matrix2D's

* **multiplyVec2** (*out_vec2*:Vec2, *m2d*:Matrix2D, *vec2*:Vec2): Vec2

  Multiplies a Matrix2D and a Vec2

* **getPosition** (*out_vec2*:Vec2, *m2d*:Matrix2D): Vec2

  Retrieve current position as Vec2

* **getScale** (*out_vec2*:Vec2, *m2d*:Matrix2D): Vec2

  Retrieve current scale as Vec2

* **getSkew** (*out_vec2*:Vec2, *m2d*:Matrix2D): Vec2

  Retrieve current skew as Vec2

* **reflect** (*out*:Matrix2D, *m2d*:Matrix2D): Matrix2D

  Alias of rotate 180º(PI)

* **inverse** (*out*:Matrix2D, *m2d*:Matrix2D)
* **transpose** (*out*:Matrix2D, *m2d*:Matrix2D)
* **determinant** (*out*:Matrix2D, *m2d*:Matrix2D)
* **translationMatrix** (*x*:Number, *y*:Number): Matrix2D

  Returns a 3x2 2D column-major translation matrix for x and y.

* **dSkewXMatrix** (*degrees*:Number (Degrees)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given degrees.

* **skewXMatrix** (*radians*:Number (Radians)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given radians.

* **dSkewYMatrix** (*degrees*:Number (Degrees)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given degrees.

* **skewYMatrix** (*radians*:Number (Radians)): Matrix2D

  Returns a 3x2 2D column-major y-skew matrix for the given radians.

* **scalingMatrix** (*x*:Number, *y*:Number)

  Returns a 3x2 2D column-major scaling matrix for sx and sy.



## Polygon
* **create** ()
* **centroid** (*out*:Polygon, *poly*:Polygon)
* **recenter** (*out*:Polygon, *poly*:Polygon)
* **area** (*poly*:Polygon)


## Beizer
* **cubic** (*cp0x*:Number, *cp0y*:Number, *cp1x*:Number, *cp1y*:Number, *cp2x*:Number, *cp2y*:Number, *cp3x*:Number, *cp3y*:Number)
* **quadric** (*cp0x*:Number, *cp0y*:Number, *cp1x*:Number, *cp1y*:Number, *cp2x*:Number, *cp2y*:Number)
* **get** (*out*:Beizer, *curve*:Beizer, *t*:Number)
* **length** (*curve*:Beizer, *step*:Number): Number

  Calculate the curve length by incrementally solving the curve every substep=CAAT.Curve.k. This value defaults

  to .05 so at least 20 iterations will be performed.

  @todo some kind of cache maybe it's needed!



## Triangle
* **create** (*x1*:Number, *y1*:Number, *x2*:Number, *y2*:Number, *x3*:Number, *y3*:Number)

  @class Triangle

* **zero** ()
* **clone** (*tri*:Triangle)
* **copy** (*out*:Triangle, *tri*:Triangle)
* **centroid** (*out_vec2*:Vec2, *tri*:Triangle)
* **incenter** (*out_vec2*:Vec2, *tri*:Triangle)
* **circumcenter** (*out_vec2*:Vec2, *tri*:Triangle)
* **area** (*tri*:Triangle)
* **translate** (*out*:Triangle, *tri*:Triangle, *vec2*:Vec2)


###  Intersection
* OUTSIDE 1
* INSIDE 2
* PARALLEL 1
* COLLIDE 4
* COINCIDENT 5
* TANGENT 6
* bb2_bb2 (bb1, bb2, collision, distance)
* bb2_vec2 (bb, vec2, collision, distance)
* vec2_bb2 (vec2, bb, collision, distance)
* rectangle_rectangle (rectangle_1, rectangle_2, collision, distance)
* bb2_rectangle (rectangle_2, bb2, collision, distance)
* rectangle_vec2 (rectangle, vec2, collision, distance)
* vec2_rectangle (vec2, rectangle, collision, distance)
* circle_vec2 (circle, vec2, collision, distance)
* vec2_circle (vec2, circle, collision, distance)
* circle_circle (acircle, bcircle, collision, distance)
* circle_bb2 (circle, bb, collision, distance)
* bb2_circle (bb, circle, collision, distance)
* circle_rectangle (circle, rect, collision, distance)
* rectangle_circle (rect, circle, collision, distance)
* circle_segment2 (circle, segment2, collision, distance)
* segment2_circle (segment2, circle, collision, distance)
* line2_line2 (aline, bline, collision, distance)
* segment2_segment2 (asegment, bsegment, collision, distance)
* segment2_vec2 (seg2, vec2)
* vec2_segment2 (vec2, seg2)

###  Transitions
* linear (zero)
* create (name, transition)
* Pow (pos)
* PowIn (pos)
* PowOut (pos)
* PowInOut (pos)
* Expo (pos)
* ExpoIn (pos)
* ExpoOut (pos)
* ExpoInOut (pos)
* Circ (pos)
* CircIn (pos)
* CircOut (pos)
* CircInOut (pos)
* Sine (pos)
* SineIn (pos)
* SineOut (pos)
* SineInOut (pos)
* Back (pos)
* BackIn (pos)
* BackOut (pos)
* BackInOut (pos)
* Bounce (pos)
* BounceIn (pos)
* BounceOut (pos)
* BounceInOut (pos)
* Elastic (pos)
* ElasticIn (pos)
* ElasticOut (pos)
* ElasticInOut (pos)
* Quad (pos)
* QuadIn (pos)
* QuadOut (pos)
* QuadInOut (pos)
* Cubic (pos)
* CubicIn (pos)
* CubicOut (pos)
* CubicInOut (pos)
* Quart (pos)
* QuartIn (pos)
* QuartOut (pos)
* QuartInOut (pos)
* Quint (pos)
* QuintIn (pos)
* QuintOut (pos)
* QuintInOut (pos)
* LINK bject
* animate (obj, prop, values, ioptions)
* tween (obj, params, options)

###  Xorshift
* create ()

###  Noise
* createClassic (seed)
* createSimpleX (seed)